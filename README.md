# js-algo
자바스크립트 알고리즘 스터디 기록
___
## 알고리즘 출제 유형 빈도
| 유형 | 출제빈도 |
|---|:---:|
| `구현` | `33%` |
| `BFS/DFS` | `20.9%` |
| `그리디` | `19.8%` |
| `정렬` | `8.2%` |
| `동적 프로그래밍` | `8.2%` |
| `이진 탐색` | `3.8%` |
| `최단 경로` | `3.3%` |
| `그래프 이론` | `2.7%` |


> 출처 : [코딩 테스트에서는 주로 기초 알고리즘에 기반하는 문제가 출제됩니다.
그중에서도 가장 출제 빈도가 높은 문제는 그리디(Greedy), 구현(Implementation), DFS/BFS를 활용한 탐색 문제입니다.](https://realhanbit.co.kr/channel/category/category_view.html?cms_code=CMS7793635735)

## * 구현
구현으로 묶이는 유형은 모든 경우의 수를 일일이 계산하는 것(brute force)으로 문제에서 하라는 대로 잘 따라하면 답이 나온다. 생각한 것을 코드로 구현할 수 있는지 보는 문제 유형.
 비효율적인 시간 복잡도를 가지고 있기 때문에 대이터 갯수가 100만개 이하일 때 적절하다. 하지만 쉽게 풀 수 있는 문제를 어렵게 생각하여 생각이 꼬일 수도 있다. 문제를 만나면 먼저 물어보자. 무식하게 풀 수 있을까?

#### 구현 문제에 접근하는 방법
보통 구현 유형은 사소한 입력 조건 등을 명시해주며 문제의 길이가 긴 편이다.
고차원적 사고력을 요구하지 않는 편이라 언어 자체에 익숙하다면 쉽게 풀 수 있다.
 matrix 2차원 공간 행렬 문제.
 완전 탐색과 시뮬레이션 문제로 나누지만 명확하게 구분할 필요는 없다.
둘의 차이는 문제에서 해결 방법을 명시하느냐 아니냐의 차이이고
brute force한 방법으로 푸는 것은 동일하다.

 ##### 정당성 검증 
고려할 사항 : 시간 / 메모리 제한 사항/ 데이터의 갯수

#### + 완전 탐색 (exhaustive search)
        모든 경우의 수를 일일이 탐색.
#### + 시뮬레이션 (simulation)
        문제에서 제시한 알고리즘을 한 단계 씩 차례대로 수행.   
        즉 수행해야 하는 모든 과정이 문제에 이미 나와있다.

---
## * BFS/DFS
 대표적인 그래프 탐색 알고리즘   
 
 ![bfsdfs](https://res.cloudinary.com/practicaldev/image/fetch/s---f65OlYQ--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/e2ru41fjhqs4ombbcedf.png "bfs and dbf")
 
### 어떤 경우에 사용해야 하는가
#### 최단 거리를 탐색해야할 때
 e.g : 친구 추천, 네비게이션 최단 거리 안내
### + BFS(Breadth First Search) 너비 우선 탐색
     탐색할 때 너비(형제 노드)를 우선 탐색하는 알고리즘.
      * 두 개의 큐를 사용한다. 큐에 각 노드 정보를 기록해야 한다.
      * 찾고자 하는 노드가 루트 노드에서부터 가까이 있다고 예상될 때 사용.

#### 경로가 존재하는지 판별해야할 때
 e.g : 미로게임
### + DFS(Depth First Search) 깊이 우선 탐색
     탐색할 때 깊이(자식 노드)를 우선 탐색하는 알고리즘.
      * 한 개의 큐와 한 개의 스택을 사용한다.
      * BFS보다 속도가 느릴 수 있다.
---
## * 그리디
[leetcode](https://leetcode.com/problemset/algorithms/?topicSlugs=greedy)

 탐욕 알고리즘, 각 단계에서 항상 더 큰 쪽으로 선택한다.
 동적 프로그래밍이 필요 이상의 작업을 수행하게 되는 경우를 보완해 고안된 알고리즘

### 어떤 경우에 사용해야 하는가
 최적 부분 구조 / 탐욕 선택 속성
 한 번의 선택이 다음 선택에는 무관한 값이어야 하며 매 순간의 최적해가 문제에 대한 최적해일 때.
 
 * 거스름돈 문제 ( 동전 가격 배수 관계가 성립될 때 [1, 5, 10, 15, 50] )
 * 활동 선택 문제 ( Activity selection problem )
 * 최소 신장 트리 ( Minimum spanning tree ) 
 * 제약 조건이 많은 대부분의 문제
 * 다익스트라 알고리즘
 * 허프만 코드
 * 크러스컬 알고리즘
 
---
### * 정렬 ( Sort )
[leetcode](https://leetcode.com/problemset/algorithms/?topicSlugs=sort)

데이터를 정렬해야 하는 이유는 [이진탐색](#이진탐색)이 가능하게 만들기 위함.
이 정렬을 어떻게 더 효율적으로 수행할 수 있을지가 핵심.



---
### 동적 계획법 ( Dynamic Programming )

---
## 이진탐색
---
## 최단 경로
---
## 그래프 이론
---


# 자료구조
  ##
                           
